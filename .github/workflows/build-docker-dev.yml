name: Build Docker (Dev)

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      path_dockerfile:
        description: "dockerfile path in repo"
        type: string
        required: true
        default: "dockerfile/Dockerfile.alpine"
      arch_branch:
        description: "Input arch"
        type: string
        required: true
        default: "linux/amd64,linux/arm64"
      base_image:
        description: "Base Image"
        type: choice
        required: true
        default: "alpine:latest"
        options:
          - "debian:stable-slim"
          - "alpine:latest"
      update_channel:
        description: "Update Channel"
        type: choice
        required: false
        default: "nightly"
        options:
          - "release"
          - "beta"
          - "nightly"
      repo_dockerhub:
        description: "Docker Hub repository"
        type: string
        required: true
        default: "grinch27/adguardvpn-cli"

env:
  tag: ${{ inputs.update_channel || 'release' }}
  base_image: ${{ inputs.base_image || 'alpine:latest' }}
  path_dockerfile: ${{ inputs.path_dockerfile || 'dockerfile/Dockerfile' }}
  arch_branch: ${{ inputs.arch_branch || 'linux/amd64,linux/arm64' }}
  repo_dockerhub: ${{ inputs.repo_dockerhub || 'grinch27/adguardvpn-cli' }}
  update_channel: ${{ inputs.update_channel || 'release' }}
  app: adguardvpn-cli

jobs:
  check:
    name: check software version
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      changed: ${{ steps.summary.outputs.changed }}
    steps:
      - name: Initialization environment
        id: init
        env:
          DEBIAN_FRONTEND: noninteractive
        working-directory: /
        run: |
          echo -e "Current working directory: $(pwd)"
          packages_install=(
            "curl"
          )
          packages_extra=(
            "skopeo"
            "jq"
          )
          sudo -E apt-get -qq -y update
          sudo -E apt-get -y install "${packages_install[@]}"
          sudo -E apt-get -y install "${packages_extra[@]}"
          sudo -E apt-get -qq -y autoremove --purge
          sudo -E apt-get -qq clean
          echo "status=success" >> ${GITHUB_OUTPUT}

      - name: Check Base image - ${{ env.base_image }}
        id: base
        env:
          container_name: base-image
        run: |
          # Read platform information from environment variables
          IFS=',' read -ra platforms <<< "${{ env.arch_branch }}"

          for platform in "${platforms[@]}"; do
            echo "========== Base Image ${{ env.base_image }} $platform =========="
            # docker pull --platform ${platform} ${{ env.base_image }}

            # Inspect the image creation time
            # docker inspect --platform ${platform} ${{ env.base_image }}

            # Stop Docker container
            # docker stop ${{ env.container_name }}

            # Skopeo inspect the image
            json_output=$(skopeo inspect \
              --override-os=$(echo $platform | awk -F'/' '{print $1}') \
              --override-arch=$(echo $platform | awk -F'/' '{print $2}') \
              --format=json \
              docker://docker.io/library/${{ env.base_image }})

            # 使用 jq 解析 JSON 输出并提取所需信息
            created=$(echo $json_output | jq -r '.Created')
            docker_version=$(echo $json_output | jq -r '.DockerVersion')
            layers=$(echo $json_output | jq -r '.Layers')
            first_layer=$(echo $layers | jq -r '.[0]')

            echo "Created: $created"
            echo "Docker Version: $docker_version"
            echo "Layers: $layers"
            echo "First Layer: $first_layer"
          done

          # Inspect the image manifest
          # docker manifest inspect ${{ env.base_image }}

          echo "changed=true" >> ${GITHUB_OUTPUT}

      - name: Check version - ${{ env.app }}
        id: app
        run: |
          # check version of software
          echo "changed=true" >> ${GITHUB_OUTPUT}

      - name: summary
        id: summary
        run: |
          # if [ "${{ steps.base.outputs.changed }}" == 'true' ] && [ "${{ steps.app.outputs.changed }}" == 'true' ]; then
          #   echo "changed=true" >> ${GITHUB_OUTPUT}
          # fi

          # debug
          # exit 1

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: check
    permissions:
      contents: write
      pull-requests: write
    services:
      registry:
        image: registry:latest
        ports:
          - 5000:5000
    steps:
      - name: Log in to Docker Hub
        uses: docker/login-action@master
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@main

      - name: Set up QEMU
        uses: docker/setup-qemu-action@master
        with:
          platforms: ${{ env.arch_branch }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@master
        with:
          driver-opts: network=host

      - name: Build and save Docker image as tar
        run: |
          docker buildx build \
            --platform ${{ env.arch_branch }} \
            --file ${{ github.workspace }}/${{ env.path_dockerfile }} \
            --tag localhost:5000/${{ env.repo_dockerhub }}:${{ env.tag }} \
            --build-arg base_image=${{ env.base_image }} \
            --build-arg update_channel=${{ env.update_channel }} \
            --push \
            .
            # --output type=tar,dest=${{ github.workspace }}/multi-platform.tar \
          echo "status=success" >> ${GITHUB_OUTPUT}

      - name: Test Docker image & Check version consistency
        id: test
        env:
          image: localhost:5000/${{ env.repo_dockerhub }}:${{ env.tag }}
          container_name: container-test
          DIR_OUTPUT: "${{ github.workspace }}/output"
        run: |
          # Inspect Docker image
          docker buildx imagetools inspect localhost:5000/${{ env.repo_dockerhub }}:${{ env.tag }}

          # Read platform information from environment variables
          IFS=',' read -ra platforms <<< "${{ env.arch_branch }}"

          # Initialize an associative array to store version information
          declare -A versions

          # Test Docker container for each platform
          for platform in "${platforms[@]}"; do
            echo "========== Testing Docker container for platform: $platform =========="

            # Pull Docker image & Run Docker container
            docker pull --platform $platform localhost:5000/${{ env.repo_dockerhub }}:${{ env.tag }}
            docker run \
              --name ${{ env.container_name }} \
              --rm \
              --detach \
              --platform $platform \
              ${{ env.image }} \
              /bin/bash -c "uname -a && sleep infinity"
            
            # If the apt policy method fails, try to get version information using adguardvpn-cli --version
            docker exec ${{ env.container_name }} adguardvpn-cli --version
            version=$(docker exec ${{ env.container_name }} adguardvpn-cli --version | awk '{print $4}' | cut -d 'v' -f 2)
            if [ -n "$version" ]; then
                versions[$version]=1
            else
                echo "Unable to get version information for ${env.app}."
            fi

            # Test DNS settings
            docker exec ${{ env.container_name }} cat /etc/resolv.conf

            # Stop Docker container
            docker stop ${{ env.container_name }}
          done

          # Get all unique version information
          unique_versions=$(IFS=','; echo "${!versions[*]}")
          echo "version=$unique_versions" | tee -a ${GITHUB_OUTPUT}

          # Check version consistency
          IFS=',' read -ra version_array <<< "$unique_versions"
          if [ "${#version_array[@]}" -eq 1 ]; then
            echo "status=success" >> ${GITHUB_OUTPUT}
          else
            echo "status=failure" >> ${GITHUB_OUTPUT}
          fi

      # - name: Push image to Docker Hub
      #   run: |
      #     function push_image {
      #       docker_repo=$1
      #       docker_tag=$2

      #       # Create multi-architecture Docker image
      #       docker buildx imagetools create --tag $docker_repo:$docker_tag localhost:5000/$docker_repo:${{ env.tag }}

      #       # Push multi-architecture Docker image
      #       docker buildx imagetools push $docker_repo:$docker_tag
      #     }

      #     # Push image with tag
      #     push_image ${{ env.repo_dockerhub }} ${{ env.tag }}

      #     # Push image with version if test is successful and not cancelled
      #     if [ "${{ steps.test.outputs.status }}" == "success" ]; then
      #       push_image ${{ env.repo_dockerhub }} ${{ steps.test.outputs.version }}
      #     fi

      #     echo "status=success" >> ${GITHUB_OUTPUT}
